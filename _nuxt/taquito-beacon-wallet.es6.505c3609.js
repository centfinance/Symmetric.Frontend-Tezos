import{bh as Te,bi as ye,bj as te,bk as C,bl as Ee,bm as I,bn as L,bo as ve,bp as Se,bq as Z,br as M,bs as E,bt as S,bu as Re,bv as U,bw as ee,bx as Ae,by as Ne,bz as _e,bA as Ie,bB as b,bC as ie,bD as ge,bE as we,bF as O,bG as V,bH as Oe,bI as P,bJ as me,bK as Ce,bL as Pe,bM as be,bN as ke,bO as ne,bP as k,bQ as oe,bR as se,bS as re,bT as ce,bU as ae,bV as le,bW as de,aA as W,bX as Ue,bY as Le,aL as De}from"./entry.a2878074.js";import{b as Me,d as xe,f as We,g as qe}from"./taquito.es6.a358f22a.js";var $=Te,Qe=function(r){function e(n){var o=Uint8Array.from(n),d=r(o),h=o.length+4,s=new Uint8Array(h);return s.set(o,0),s.set(d.subarray(0,4),o.length),$.encode(s,h)}function t(n){var o=n.slice(0,-4),d=n.slice(-4),h=r(o);if(!(d[0]^h[0]|d[1]^h[1]|d[2]^h[2]|d[3]^h[3]))return o}function i(n){var o=$.decodeUnsafe(n);if(o)return t(o)}function c(n){var o=$.decode(n),d=t(o);if(!d)throw new Error("Invalid checksum");return d}return{encode:e,decode:c,decodeUnsafe:i}},{sha256:he}=ye,Ke=Qe;function He(r){return he(he(r))}var Be=Ke(He);const F=r=>r.length>=12?`${r.substr(0,5)}...${r.substr(-5)}`:r;var v=globalThis&&globalThis.__awaiter||function(r,e,t,i){function c(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function d(a){try{s(i.next(a))}catch(u){o(u)}}function h(a){try{s(i.throw(a))}catch(u){o(u)}}function s(a){a.done?n(a.value):c(a.value).then(d,h)}s((i=i.apply(r,e||[])).next())})};const D=new M("BeaconEvents"),x=5*1e3;var l;(function(r){r.PERMISSION_REQUEST_SENT="PERMISSION_REQUEST_SENT",r.PERMISSION_REQUEST_SUCCESS="PERMISSION_REQUEST_SUCCESS",r.PERMISSION_REQUEST_ERROR="PERMISSION_REQUEST_ERROR",r.OPERATION_REQUEST_SENT="OPERATION_REQUEST_SENT",r.OPERATION_REQUEST_SUCCESS="OPERATION_REQUEST_SUCCESS",r.OPERATION_REQUEST_ERROR="OPERATION_REQUEST_ERROR",r.SIGN_REQUEST_SENT="SIGN_REQUEST_SENT",r.SIGN_REQUEST_SUCCESS="SIGN_REQUEST_SUCCESS",r.SIGN_REQUEST_ERROR="SIGN_REQUEST_ERROR",r.BROADCAST_REQUEST_SENT="BROADCAST_REQUEST_SENT",r.BROADCAST_REQUEST_SUCCESS="BROADCAST_REQUEST_SUCCESS",r.BROADCAST_REQUEST_ERROR="BROADCAST_REQUEST_ERROR",r.ACKNOWLEDGE_RECEIVED="ACKNOWLEDGE_RECEIVED",r.LOCAL_RATE_LIMIT_REACHED="LOCAL_RATE_LIMIT_REACHED",r.NO_PERMISSIONS="NO_PERMISSIONS",r.ACTIVE_ACCOUNT_SET="ACTIVE_ACCOUNT_SET",r.ACTIVE_TRANSPORT_SET="ACTIVE_TRANSPORT_SET",r.SHOW_PREPARE="SHOW_PREPARE",r.HIDE_UI="HIDE_UI",r.PAIR_INIT="PAIR_INIT",r.PAIR_SUCCESS="PAIR_SUCCESS",r.CHANNEL_CLOSED="CHANNEL_CLOSED",r.INTERNAL_ERROR="INTERNAL_ERROR",r.UNKNOWN="UNKNOWN"})(l||(l={}));const q=r=>v(void 0,void 0,void 0,function*(){let e;const t=[];if(r.walletInfo.deeplink&&(r.walletInfo.type==="web"||r.walletInfo.type==="mobile"&&te(window)||r.walletInfo.type==="desktop"&&!te(window))){const i=r.walletInfo.deeplink;e=()=>v(void 0,void 0,void 0,function*(){const c=document.createElement("a");c.setAttribute("rel","noopener"),c.setAttribute("href",i),c.setAttribute("target","_blank"),c.dispatchEvent(new MouseEvent("click",{view:window,bubbles:!0,cancelable:!0}))})}t.push({text:"No answer from your wallet received yet. Please make sure the wallet is open.",isBold:!0}),t.push({text:"Did you make a mistake?",actionText:"Cancel Request",actionCallback:()=>v(void 0,void 0,void 0,function*(){yield I()})}),t.push({text:"Wallet not receiving request?",actionText:"Reset Connection",actionCallback:()=>v(void 0,void 0,void 0,function*(){yield I();const i=r.extraInfo.resetCallback;i&&(D.log("showSentToast","resetCallback invoked"),yield i())})}),C({body:"Request sent to  {{wallet}}",walletInfo:r.walletInfo,state:"loading",actions:t,openWalletAction:e}).catch(i=>console.error(i))}),Fe=r=>v(void 0,void 0,void 0,function*(){C({body:"Awaiting confirmation in  {{wallet}}",state:"acknowledge",walletInfo:r.walletInfo}).catch(e=>console.error(e))}),Ge=r=>v(void 0,void 0,void 0,function*(){const e=r.walletInfo?"Preparing Request for  {{wallet}}...":"Preparing Request...";C({body:e,state:"prepare",walletInfo:r.walletInfo}).catch(t=>console.error(t))}),je=r=>v(void 0,void 0,void 0,function*(){r?(r.includes("alert")&&Ee(),r.includes("toast")&&I()):I()}),Ve=()=>v(void 0,void 0,void 0,function*(){yield L({title:"No Permission",body:"Please allow the wallet to handle this type of request."})}),Q=(r,e)=>v(void 0,void 0,void 0,function*(){var t,i,c,n,o,d;const h=r.errorResponse.errorType?ve.getError(r.errorResponse.errorType,r.errorResponse.errorData):new Se,s=[{text:h.title,isBold:!0}];if(r.errorResponse.errorType===Z.TRANSACTION_INVALID_ERROR&&r.errorResponse.errorData){const a=r.errorResponse.errorData,u=r.errorMessages;let f=!1;if(!((t=a[0])===null||t===void 0)&&t.contract_handle&&u&&(u!=null&&u[a[0].contract_handle])){const N=(n=(c=(i=a[1])===null||i===void 0?void 0:i.with)===null||c===void 0?void 0:c.int)!==null&&n!==void 0?n:(d=(o=a[1])===null||o===void 0?void 0:o.with)===null||d===void 0?void 0:d.string,A=u==null?void 0:u[a[0].contract_handle];N&&(A!=null&&A[N])&&(s.push({text:A==null?void 0:A[N],isBold:!0}),f=!0)}f||s.push({text:h.description}),s.push({text:"",actionText:"Show Details",actionCallback:()=>v(void 0,void 0,void 0,function*(){yield I(),yield L({title:h.title,body:h.fullDescription.description,data:h.fullDescription.data,buttons:e})})})}yield C({body:"{{wallet}}  has returned an error",timer:r.errorResponse.errorType===Z.ABORTED_ERROR?x:void 0,state:"finished",walletInfo:r.walletInfo,actions:s})}),$e=()=>v(void 0,void 0,void 0,function*(){L({title:"Error",body:"Rate limit reached. Please slow down",buttons:[{text:"Done",style:"outline"}],timer:3e3}).catch(r=>console.error(r))}),ze=()=>v(void 0,void 0,void 0,function*(){yield Ee()}),Ye=()=>v(void 0,void 0,void 0,function*(){yield L({title:"Channel closed",body:"Your peer has closed the connection.",buttons:[{text:"Done",style:"outline"}],timer:1500})}),Je=r=>v(void 0,void 0,void 0,function*(){var e;const t=[...(e=r.buttons)!==null&&e!==void 0?e:[]];t.push({text:"Done",style:"outline"});const i={title:"Internal Error",body:r.text,buttons:t};yield L(i)}),Xe=r=>v(void 0,void 0,void 0,function*(){console.log("showPairAlert");const e={title:"Choose your preferred wallet",body:"<p></p>",pairingPayload:{p2pSyncCode:r.p2pPeerInfo,walletConnectSyncCode:r.walletConnectPeerInfo,postmessageSyncCode:r.postmessagePeerInfo,preferredNetwork:r.preferredNetwork},closeButtonCallback:r.abortedHandler,disclaimerText:r.disclaimerText,analytics:r.analytics,featuredWallets:r.featuredWallets};yield L(e)}),Ze=r=>v(void 0,void 0,void 0,function*(){const{output:e}=r;yield C({body:"{{wallet}}  has granted permission",timer:x,walletInfo:r.walletInfo,state:"finished",actions:[{text:"Address",actionText:F(e.address),isBold:!0},{text:"Network",actionText:`${e.network.type}`},{text:"Permissions",actionText:e.scopes.join(", ")}]})}),et=r=>v(void 0,void 0,void 0,function*(){const{account:e,output:t,blockExplorer:i}=r;yield C({body:"{{wallet}}  successfully submitted operation",timer:x,state:"finished",walletInfo:r.walletInfo,actions:[{text:F(t.transactionHash),isBold:!0,actionText:"Open Blockexplorer",actionLogo:"external",actionCallback:()=>v(void 0,void 0,void 0,function*(){const c=yield i.getTransactionLink(t.transactionHash,e.network);window.open(c,"_blank","noopener"),yield I()})}]})}),tt=r=>v(void 0,void 0,void 0,function*(){const e=r.output;yield C({body:"{{wallet}}  successfully signed payload",timer:x,state:"finished",walletInfo:r.walletInfo,actions:[{text:`Signature: ${F(e.signature)}`,actionText:"Copy to clipboard",actionCallback:()=>v(void 0,void 0,void 0,function*(){navigator.clipboard.writeText(e.signature).then(()=>{D.log("showSignSuccessAlert","Copying to clipboard was successful!")},t=>{D.error("showSignSuccessAlert","Could not copy text to clipboard: ",t)}),yield I()})}]})}),it=r=>v(void 0,void 0,void 0,function*(){const{network:e,output:t,blockExplorer:i}=r;yield C({body:"{{wallet}}  successfully injected operation",timer:x,state:"finished",walletInfo:r.walletInfo,actions:[{text:F(t.transactionHash),isBold:!0,actionText:"Open Blockexplorer",actionLogo:"external",actionCallback:()=>v(void 0,void 0,void 0,function*(){const c=yield i.getTransactionLink(t.transactionHash,e);window.open(c,"_blank","noopener"),yield I()})}]})}),z=()=>()=>v(void 0,void 0,void 0,function*(){}),T={[l.PERMISSION_REQUEST_SENT]:q,[l.PERMISSION_REQUEST_SUCCESS]:Ze,[l.PERMISSION_REQUEST_ERROR]:Q,[l.OPERATION_REQUEST_SENT]:q,[l.OPERATION_REQUEST_SUCCESS]:et,[l.OPERATION_REQUEST_ERROR]:Q,[l.SIGN_REQUEST_SENT]:q,[l.SIGN_REQUEST_SUCCESS]:tt,[l.SIGN_REQUEST_ERROR]:Q,[l.BROADCAST_REQUEST_SENT]:q,[l.BROADCAST_REQUEST_SUCCESS]:it,[l.BROADCAST_REQUEST_ERROR]:Q,[l.ACKNOWLEDGE_RECEIVED]:Fe,[l.LOCAL_RATE_LIMIT_REACHED]:$e,[l.NO_PERMISSIONS]:Ve,[l.ACTIVE_ACCOUNT_SET]:z(),[l.ACTIVE_TRANSPORT_SET]:z(),[l.SHOW_PREPARE]:Ge,[l.HIDE_UI]:je,[l.PAIR_INIT]:Xe,[l.PAIR_SUCCESS]:ze,[l.CHANNEL_CLOSED]:Ye,[l.INTERNAL_ERROR]:Je,[l.UNKNOWN]:z()};class ue{constructor(e={},t){this.callbackMap={[l.PERMISSION_REQUEST_SENT]:[T.PERMISSION_REQUEST_SENT],[l.PERMISSION_REQUEST_SUCCESS]:[T.PERMISSION_REQUEST_SUCCESS],[l.PERMISSION_REQUEST_ERROR]:[T.PERMISSION_REQUEST_ERROR],[l.OPERATION_REQUEST_SENT]:[T.OPERATION_REQUEST_SENT],[l.OPERATION_REQUEST_SUCCESS]:[T.OPERATION_REQUEST_SUCCESS],[l.OPERATION_REQUEST_ERROR]:[T.OPERATION_REQUEST_ERROR],[l.SIGN_REQUEST_SENT]:[T.SIGN_REQUEST_SENT],[l.SIGN_REQUEST_SUCCESS]:[T.SIGN_REQUEST_SUCCESS],[l.SIGN_REQUEST_ERROR]:[T.SIGN_REQUEST_ERROR],[l.BROADCAST_REQUEST_SENT]:[T.BROADCAST_REQUEST_SENT],[l.BROADCAST_REQUEST_SUCCESS]:[T.BROADCAST_REQUEST_SUCCESS],[l.BROADCAST_REQUEST_ERROR]:[T.BROADCAST_REQUEST_ERROR],[l.ACKNOWLEDGE_RECEIVED]:[T.ACKNOWLEDGE_RECEIVED],[l.LOCAL_RATE_LIMIT_REACHED]:[T.LOCAL_RATE_LIMIT_REACHED],[l.NO_PERMISSIONS]:[T.NO_PERMISSIONS],[l.ACTIVE_ACCOUNT_SET]:[T.ACTIVE_ACCOUNT_SET],[l.ACTIVE_TRANSPORT_SET]:[T.ACTIVE_TRANSPORT_SET],[l.SHOW_PREPARE]:[T.SHOW_PREPARE],[l.HIDE_UI]:[T.HIDE_UI],[l.PAIR_INIT]:[T.PAIR_INIT],[l.PAIR_SUCCESS]:[T.PAIR_SUCCESS],[l.CHANNEL_CLOSED]:[T.CHANNEL_CLOSED],[l.INTERNAL_ERROR]:[T.INTERNAL_ERROR],[l.UNKNOWN]:[T.UNKNOWN]},t&&this.setAllHandlers(),this.overrideDefaults(e)}on(e,t){return v(this,void 0,void 0,function*(){const i=this.callbackMap[e]||[];i.push(t),this.callbackMap[e]=i})}emit(e,t,i){return v(this,void 0,void 0,function*(){const c=this.callbackMap[e];c&&c.length>0&&c.forEach(n=>v(this,void 0,void 0,function*(){try{yield n(t,i)}catch(o){D.error(`error handling event ${e}`,o)}}))})}overrideDefaults(e){Object.keys(e).forEach(t=>{const i=t,c=e[i];c&&(this.callbackMap[i]=[c.handler])})}setAllHandlers(e){Object.keys(this.callbackMap).forEach(t=>{const i=t;this.callbackMap[i]=[],e?this.callbackMap[i].push(e):this.callbackMap[i].push((...c)=>{D.log(t,...c)})})}}const K={[E.BlockchainRequest]:{sent:l.UNKNOWN,success:l.UNKNOWN,error:l.UNKNOWN},[E.BlockchainResponse]:{sent:l.UNKNOWN,success:l.UNKNOWN,error:l.UNKNOWN},[E.PermissionRequest]:{sent:l.PERMISSION_REQUEST_SENT,success:l.PERMISSION_REQUEST_SUCCESS,error:l.PERMISSION_REQUEST_ERROR},[E.PermissionResponse]:{sent:l.UNKNOWN,success:l.UNKNOWN,error:l.UNKNOWN},[E.OperationRequest]:{sent:l.OPERATION_REQUEST_SENT,success:l.OPERATION_REQUEST_SUCCESS,error:l.OPERATION_REQUEST_ERROR},[E.OperationResponse]:{sent:l.UNKNOWN,success:l.UNKNOWN,error:l.UNKNOWN},[E.SignPayloadRequest]:{sent:l.SIGN_REQUEST_SENT,success:l.SIGN_REQUEST_SUCCESS,error:l.SIGN_REQUEST_ERROR},[E.SignPayloadResponse]:{sent:l.UNKNOWN,success:l.UNKNOWN,error:l.UNKNOWN},[E.BroadcastRequest]:{sent:l.BROADCAST_REQUEST_SENT,success:l.BROADCAST_REQUEST_SUCCESS,error:l.BROADCAST_REQUEST_ERROR},[E.BroadcastResponse]:{sent:l.UNKNOWN,success:l.UNKNOWN,error:l.UNKNOWN},[E.Acknowledge]:{sent:l.UNKNOWN,success:l.UNKNOWN,error:l.UNKNOWN},[E.Disconnect]:{sent:l.UNKNOWN,success:l.UNKNOWN,error:l.UNKNOWN},[E.Error]:{sent:l.UNKNOWN,success:l.UNKNOWN,error:l.UNKNOWN}};var nt=globalThis&&globalThis.__awaiter||function(r,e,t,i){function c(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function d(a){try{s(i.next(a))}catch(u){o(u)}}function h(a){try{s(i.throw(a))}catch(u){o(u)}}function s(a){a.done?n(a.value):c(a.value).then(d,h)}s((i=i.apply(r,e||[])).next())})};class ot{constructor(e){this.rpcUrls=e}getLinkForNetwork(e){return nt(this,void 0,void 0,function*(){return this.rpcUrls[e.type]})}}var pe=globalThis&&globalThis.__awaiter||function(r,e,t,i){function c(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function d(a){try{s(i.next(a))}catch(u){o(u)}}function h(a){try{s(i.throw(a))}catch(u){o(u)}}function s(a){a.done?n(a.value):c(a.value).then(d,h)}s((i=i.apply(r,e||[])).next())})};class st extends ot{constructor(e={[S.MAINNET]:"https://tzkt.io",[S.GHOSTNET]:"https://ghostnet.tzkt.io",[S.MONDAYNET]:"https://mondaynet.tzkt.io",[S.DAILYNET]:"https://dailynet.tzkt.io",[S.DELPHINET]:"https://delphinet.tzkt.io",[S.EDONET]:"https://edonet.tzkt.io",[S.FLORENCENET]:"https://florencenet.tzkt.io",[S.GRANADANET]:"https://granadanet.tzkt.io",[S.HANGZHOUNET]:"https://hangzhounet.tzkt.io",[S.ITHACANET]:"https://ithacanet.tzkt.io",[S.JAKARTANET]:"https://jakartanet.tzkt.io",[S.KATHMANDUNET]:"https://kathmandunet.tzkt.io",[S.LIMANET]:"https://limanet.tzkt.io",[S.MUMBAINET]:"https://mumbainet.tzkt.io",[S.CUSTOM]:"https://mumbainet.tzkt.io"}){super(e),this.rpcUrls=e}getAddressLink(e,t){return pe(this,void 0,void 0,function*(){return`${yield this.getLinkForNetwork(t)}/${e}`})}getTransactionLink(e,t){return pe(this,void 0,void 0,function*(){return`${yield this.getLinkForNetwork(t)}/${e}`})}}var H=globalThis&&globalThis.__awaiter||function(r,e,t,i){function c(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function d(a){try{s(i.next(a))}catch(u){o(u)}}function h(a){try{s(i.throw(a))}catch(u){o(u)}}function s(a){a.done?n(a.value):c(a.value).then(d,h)}s((i=i.apply(r,e||[])).next())})};const Y=new M("DappPostMessageTransport");class rt extends Re{constructor(e,t,i){super(e,t,i,U.TRANSPORT_POSTMESSAGE_PEERS_DAPP)}startOpenChannelListener(){return H(this,void 0,void 0,function*(){return this.client.listenForChannelOpening(e=>H(this,void 0,void 0,function*(){Y.log("connect","received PostMessagePairingResponse",e),yield this.addPeer(e),this._isConnected=ee.CONNECTED,this.newPeerListener&&(this.newPeerListener(e),this.newPeerListener=void 0)}))})}listenForNewPeer(e){return H(this,void 0,void 0,function*(){Y.log("listenForNewPeer"),this.newPeerListener=e})}stopListeningForNewPeers(){return H(this,void 0,void 0,function*(){Y.log("stopListeningForNewPeers"),this.newPeerListener=void 0})}}var B=globalThis&&globalThis.__awaiter||function(r,e,t,i){function c(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function d(a){try{s(i.next(a))}catch(u){o(u)}}function h(a){try{s(i.throw(a))}catch(u){o(u)}}function s(a){a.done?n(a.value):c(a.value).then(d,h)}s((i=i.apply(r,e||[])).next())})};const J=new M("DappP2PTransport");class ct extends Ae{constructor(e,t,i,c,n,o){super(e,t,i,c,U.TRANSPORT_P2P_PEERS_DAPP,n,o)}startOpenChannelListener(){return B(this,void 0,void 0,function*(){return this.client.listenForChannelOpening(e=>B(this,void 0,void 0,function*(){J.log("listenForNewPeer","new publicKey",e.publicKey),yield this.addPeer(e),this._isConnected=ee.CONNECTED,this.newPeerListener&&(this.newPeerListener(e),this.newPeerListener=void 0)}))})}listenForNewPeer(e){return B(this,void 0,void 0,function*(){J.log("listenForNewPeer"),this.newPeerListener=e})}stopListeningForNewPeers(){return B(this,void 0,void 0,function*(){J.log("stopListeningForNewPeers"),this.newPeerListener=void 0})}}var X=globalThis&&globalThis.__awaiter||function(r,e,t,i){function c(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function d(a){try{s(i.next(a))}catch(u){o(u)}}function h(a){try{s(i.throw(a))}catch(u){o(u)}}function s(a){a.done?n(a.value):c(a.value).then(d,h)}s((i=i.apply(r,e||[])).next())})};const at=new M("DappWalletConnectTransport");class lt extends Ne{constructor(e,t,i,c){super(e,t,i,U.TRANSPORT_WALLETCONNECT_PEERS_DAPP,c),this.client.listenForChannelOpening(n=>X(this,void 0,void 0,function*(){yield this.addPeer(n),this._isConnected=ee.CONNECTED,this.newPeerListener&&(this.newPeerListener(n),this.newPeerListener=void 0)}))}listenForNewPeer(e){return X(this,void 0,void 0,function*(){this.newPeerListener=e})}stopListeningForNewPeers(){return X(this,void 0,void 0,function*(){at.log("stopListeningForNewPeers"),this.newPeerListener=void 0})}}var p=globalThis&&globalThis.__awaiter||function(r,e,t,i){function c(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function d(a){try{s(i.next(a))}catch(u){o(u)}}function h(a){try{s(i.throw(a))}catch(u){o(u)}}function s(a){a.done?n(a.value):c(a.value).then(d,h)}s((i=i.apply(r,e||[])).next())})};const y=new M("DAppClient");class dt extends _e{constructor(e){var t,i,c,n,o,d,h;super(Object.assign({storage:e&&e.storage?e.storage:new Ie},e)),this.events=new ue,this.openRequests=new Map,this._activeAccount=new b,this._activePeer=new b,this.blockchains=new Map,this.description=e.description,this.wcProjectId=((t=e.walletConnectOptions)===null||t===void 0?void 0:t.projectId)||"24469fd0a06df227b6e5f7dc7de0ff4f",this.wcRelayUrl=(i=e.walletConnectOptions)===null||i===void 0?void 0:i.relayUrl,this.featuredWallets=e.featuredWallets,this.events=new ue(e.eventHandlers,(c=e.disableDefaultEvents)!==null&&c!==void 0?c:!1),this.blockExplorer=(n=e.blockExplorer)!==null&&n!==void 0?n:new st,this.preferredNetwork=(o=e.preferredNetwork)!==null&&o!==void 0?o:S.MAINNET,ie((d=e.colorMode)!==null&&d!==void 0?d:ge.LIGHT),this.disclaimerText=e.disclaimerText,this.errorMessages=(h=e.errorMessages)!==null&&h!==void 0?h:{},this.appMetadataManager=new we(this.storage),this.activeAccountLoaded=this.storage.get(U.ACTIVE_ACCOUNT).then(s=>p(this,void 0,void 0,function*(){s?yield this.setActiveAccount(yield this.accountManager.getAccount(s)):yield this.setActiveAccount(void 0)})).catch(s=>p(this,void 0,void 0,function*(){yield this.setActiveAccount(void 0),console.error(s)})),this.handleResponse=(s,a)=>p(this,void 0,void 0,function*(){var u,f,N;const A=this.openRequests.get(s.id);if(console.log("### openRequest ###",A),y.log("handleResponse","Received message",s,a),console.log("### message ###",JSON.stringify(s)),console.log("### connectionInfo ###",a),s.version==="3"){const R=s;if(A&&R.message.type===E.Acknowledge)this.analytics.track("event","DAppClient","Acknowledge received from Wallet"),y.log(`acknowledge message received for ${s.id}`),console.timeLog(s.id,"acknowledge"),this.events.emit(l.ACKNOWLEDGE_RECEIVED,{message:R.message,extraInfo:{},walletInfo:yield this.getWalletInfo()}).catch(console.error);else if(A){const _=R.message.blockchainData.appMetadata;R.message.type===E.PermissionResponse&&_&&(yield this.appMetadataManager.addAppMetadata(_)),console.timeLog(R.id,"response"),console.timeEnd(R.id),R.message.type===E.Error?A.reject(R.message):A.resolve({message:s,connectionInfo:a}),this.openRequests.delete(R.id)}else if(R.message.type===E.Disconnect){this.analytics.track("event","DAppClient","Disconnect received from Wallet");const _=a.origin===O.P2P?this.p2pTransport:(u=this.postMessageTransport)!==null&&u!==void 0?u:yield this.transport;if(_){const w=(yield _.getPeers()).find(j=>j.senderId===s.senderId);w?(yield _.removePeer(w),yield this.removeAccountsForPeers([w]),yield this.events.emit(l.CHANNEL_CLOSED)):y.error("handleDisconnect","cannot find peer for sender ID",s.senderId)}}else y.error("handleResponse","no request found for id ",s.id,s)}else{const R=s;if(A&&R.type===E.Acknowledge)y.log(`acknowledge message received for ${s.id}`),this.analytics.track("event","DAppClient","Acknowledge received from Wallet"),console.timeLog(s.id,"acknowledge"),this.events.emit(l.ACKNOWLEDGE_RECEIVED,{message:R,extraInfo:{},walletInfo:yield this.getWalletInfo()}).catch(console.error);else if(A)R.type===E.PermissionResponse&&R.appMetadata&&(yield this.appMetadataManager.addAppMetadata(R.appMetadata)),console.timeLog(R.id,"response"),console.timeEnd(R.id),R.type===E.Error||s.errorType?A.reject(R):A.resolve({message:s,connectionInfo:a}),this.openRequests.delete(R.id);else if(R.type===E.Disconnect||((f=s==null?void 0:s.typedMessage)===null||f===void 0?void 0:f.type)===E.Disconnect){this.analytics.track("event","DAppClient","Disconnect received from Wallet");const _=a.origin===O.P2P?this.p2pTransport:(N=this.postMessageTransport)!==null&&N!==void 0?N:yield this.transport;if(_){const w=(yield _.getPeers()).find(j=>j.senderId===s.senderId);w?(yield _.removePeer(w),yield this.removeAccountsForPeers([w]),yield this.events.emit(l.CHANNEL_CLOSED)):y.error("handleDisconnect","cannot find peer for sender ID",s.senderId)}}else y.error("handleResponse","no request found for id ",s.id,s)}})}initInternalTransports(){var e,t;return p(this,void 0,void 0,function*(){const i=yield this.keyPair;if(this.postMessageTransport||this.p2pTransport||this.walletConnectTransport)return;this.postMessageTransport=new rt(this.name,i,this.storage),yield this.addListener(this.postMessageTransport),this.p2pTransport=new ct(this.name,i,this.storage,this.matrixNodes,this.iconUrl,this.appUrl),yield this.addListener(this.p2pTransport);const c={projectId:this.wcProjectId,relayUrl:this.wcRelayUrl,metadata:{name:this.name,description:(e=this.description)!==null&&e!==void 0?e:"",url:(t=this.appUrl)!==null&&t!==void 0?t:"",icons:this.iconUrl?[this.iconUrl]:[]}};this.walletConnectTransport=new lt(this.name,i,this.storage,c),yield this.addListener(this.walletConnectTransport)})}init(e){const t=Object.create(null,{init:{get:()=>super.init}});return p(this,void 0,void 0,function*(){if(this._initPromise)return this._initPromise;try{yield this.activeAccountLoaded}catch{}return this._initPromise=new Promise(i=>p(this,void 0,void 0,function*(){if(e)yield this.addListener(e),i(yield t.init.call(this,e));else if(this._transport.isSettled())yield(yield this.transport).connect(),i(yield t.init.call(this,yield this.transport));else{const c=yield this.getActiveAccount(),n=()=>{this.postMessageTransport&&this.postMessageTransport.stopListeningForNewPeers().catch(console.error),this.p2pTransport&&this.p2pTransport.stopListeningForNewPeers().catch(console.error),this.walletConnectTransport&&this.walletConnectTransport.stopListeningForNewPeers().catch(console.error)};if(yield this.initInternalTransports(),!this.postMessageTransport||!this.p2pTransport||!this.walletConnectTransport)return;if(this.postMessageTransport.connect().then().catch(console.error),c&&c.origin){const o=c.origin.type;o===O.EXTENSION?i(yield t.init.call(this,this.postMessageTransport)):o===O.P2P?i(yield t.init.call(this,this.p2pTransport)):o===O.WALLETCONNECT&&i(yield t.init.call(this,this.walletConnectTransport))}else{const o=this.p2pTransport,d=this.postMessageTransport,h=this.walletConnectTransport;d.listenForNewPeer(s=>{y.log("init","postmessage transport peer connected",s),this.analytics.track("event","DAppClient","Extension connected",{peerName:s.name}),this.events.emit(l.PAIR_SUCCESS,s).catch(a=>console.warn(a)),this.setActivePeer(s).catch(console.error),this.setTransport(this.postMessageTransport).catch(console.error),n(),i(V.POST_MESSAGE)}).catch(console.error),o.listenForNewPeer(s=>{y.log("init","p2p transport peer connected",s),this.analytics.track("event","DAppClient","Beacon Wallet connected",{peerName:s.name}),this.events.emit(l.PAIR_SUCCESS,s).catch(a=>console.warn(a)),this.setActivePeer(s).catch(console.error),this.setTransport(this.p2pTransport).catch(console.error),n(),i(V.P2P)}).catch(console.error),h.listenForNewPeer(s=>{y.log("init","walletconnect transport peer connected",s),this.analytics.track("event","DAppClient","WalletConnect Wallet connected",{peerName:s.name}),this.events.emit(l.PAIR_SUCCESS,s).catch(a=>console.warn(a)),this.setActivePeer(s).catch(console.error),this.setTransport(this.walletConnectTransport).catch(console.error),n(),i(V.WALLETCONNECT)}).catch(console.error),Re.getAvailableExtensions().then(s=>p(this,void 0,void 0,function*(){this.analytics.track("event","DAppClient","Extensions detected",{extensions:s}),this.events.emit(l.PAIR_INIT,{p2pPeerInfo:()=>(o.connect().then().catch(console.error),o.getPairingRequestInfo()),postmessagePeerInfo:()=>d.getPairingRequestInfo(),walletConnectPeerInfo:()=>h.getPairingRequestInfo(),preferredNetwork:this.preferredNetwork,abortedHandler:()=>{console.log("ABORTED"),this._initPromise=void 0},disclaimerText:this.disclaimerText,analytics:this.analytics,featuredWallets:this.featuredWallets}).catch(a=>console.warn(a))})).catch(s=>{this._initPromise=void 0,console.error(s)})}}})),this._initPromise})}getActiveAccount(){return p(this,void 0,void 0,function*(){return this._activeAccount.promise})}setActiveAccount(e){return p(this,void 0,void 0,function*(){if(this._activeAccount.isSettled()?this._activeAccount=b.resolve(e):this._activeAccount.resolve(e),e){const t=e.origin.type;yield this.initInternalTransports(),t===O.EXTENSION?yield this.setTransport(this.postMessageTransport):t===O.P2P?yield this.setTransport(this.p2pTransport):t===O.WALLETCONNECT&&(yield this.setTransport(this.walletConnectTransport));const i=yield this.getPeer(e);yield this.setActivePeer(i)}else yield this.setActivePeer(void 0),yield this.setTransport(void 0);yield this.storage.set(U.ACTIVE_ACCOUNT,e?e.accountIdentifier:void 0),yield this.events.emit(l.ACTIVE_ACCOUNT_SET,e)})}clearActiveAccount(){return this.setActiveAccount()}setColorMode(e){return p(this,void 0,void 0,function*(){return ie(e)})}getColorMode(){return p(this,void 0,void 0,function*(){return Oe()})}getAppMetadata(){return p(this,void 0,void 0,function*(){return this.getOwnAppMetadata()})}showPrepare(){return p(this,void 0,void 0,function*(){const e=yield(()=>p(this,void 0,void 0,function*(){try{return yield this.getWalletInfo()}catch{return}}))();yield this.events.emit(l.SHOW_PREPARE,{walletInfo:e})})}hideUI(e){return p(this,void 0,void 0,function*(){yield this.events.emit(l.HIDE_UI,e)})}removeAccount(e){const t=Object.create(null,{removeAccount:{get:()=>super.removeAccount}});return p(this,void 0,void 0,function*(){const i=t.removeAccount.call(this,e),c=yield this.getActiveAccount();return c&&c.accountIdentifier===e&&(yield this.setActiveAccount(void 0)),i})}removeAllAccounts(){const e=Object.create(null,{removeAllAccounts:{get:()=>super.removeAllAccounts}});return p(this,void 0,void 0,function*(){yield e.removeAllAccounts.call(this),yield this.setActiveAccount(void 0)})}removePeer(e,t=!1){return p(this,void 0,void 0,function*(){const i=yield this.transport,c=i.removePeer(e);return yield this.removeAccountsForPeers([e]),t&&(yield this.sendDisconnectToPeer(e,i)),c})}removeAllPeers(e=!1){return p(this,void 0,void 0,function*(){const t=yield this.transport,i=yield t.getPeers(),c=t.removeAllPeers();if(yield this.removeAccountsForPeers(i),e){const n=i.map(o=>this.sendDisconnectToPeer(o,t));yield Promise.all(n)}return c})}subscribeToEvent(e,t){return p(this,void 0,void 0,function*(){yield this.events.on(e,t)})}checkPermissions(e){return p(this,void 0,void 0,function*(){if(e===E.PermissionRequest)return!0;const t=yield this.getActiveAccount();if(!t)throw yield this.sendInternalError("No active account set!");const i=t.scopes;switch(e){case E.OperationRequest:return i.includes(P.OPERATION_REQUEST);case E.SignPayloadRequest:return i.includes(P.SIGN);case E.BroadcastRequest:return!0;default:return!1}})}sendNotification(e,t,i,c){var n,o,d;return p(this,void 0,void 0,function*(){const h=yield this.getActiveAccount();if(!h||h&&!h.scopes.includes(P.NOTIFICATION)&&!h.notification)throw new Error("notification permissions not given");if(!(!((n=h.notification)===null||n===void 0)&&n.token))throw new Error("No AccessToken");const s=(o=h.notification)===null||o===void 0?void 0:o.apiUrl;if(!s)throw new Error("No Push URL set");return this.sendNotificationWithAccessToken({url:s,recipient:h.address,title:e,body:t,payload:i,protocolIdentifier:c,accessToken:(d=h.notification)===null||d===void 0?void 0:d.token})})}addBlockchain(e){this.blockchains.set(e.identifier,e),e.getWalletLists().then(t=>{me(t.desktopList),Ce(t.extensionList),Pe(t.webList),be(t.iOSList)})}removeBlockchain(e){this.blockchains.delete(e)}permissionRequest(e){return p(this,void 0,void 0,function*(){console.log("PERMISSION REQUEST");const t=this.blockchains.get(e.blockchainIdentifier);if(!t)throw new Error(`Blockchain "${e.blockchainIdentifier}" not supported by dAppClient`);const i=Object.assign(Object.assign({},e),{type:E.PermissionRequest,blockchainData:Object.assign(Object.assign({},e.blockchainData),{appMetadata:yield this.getOwnAppMetadata()})});console.log("REQUESTION PERMIMISSION V3","xxx",i);const{message:c,connectionInfo:n}=yield this.makeRequestV3(i).catch(h=>p(this,void 0,void 0,function*(){throw new Error("TODO")}));console.log("RESPONSE V3",c,n);const o=yield t.getAccountInfosFromPermissionResponse(c.message),d={accountIdentifier:o[0].accountId,senderId:c.senderId,origin:{type:n.origin,id:n.id},address:o[0].address,publicKey:o[0].publicKey,scopes:c.message.blockchainData.scopes,connectedAt:new Date().getTime(),chainData:c.message.blockchainData};return yield this.accountManager.addAccount(d),yield this.setActiveAccount(d),yield t.handleResponse({request:i,account:d,output:c,blockExplorer:this.blockExplorer,connectionContext:n,walletInfo:yield this.getWalletInfo()}),yield this.notifySuccess(i,{account:d,output:{address:o[0].address,network:{type:S.MAINNET},scopes:[P.OPERATION_REQUEST]},blockExplorer:this.blockExplorer,connectionContext:n,walletInfo:yield this.getWalletInfo()}),c.message})}request(e){return p(this,void 0,void 0,function*(){console.log("REQUEST",e);const t=this.blockchains.get(e.blockchainIdentifier);if(!t)throw new Error(`Blockchain "${t}" not supported by dAppClient`);yield t.validateRequest(e);const i=yield this.getActiveAccount();if(!i)throw yield this.sendInternalError("No active account!");const c=Object.assign(Object.assign({},e),{type:E.BlockchainRequest,accountId:i.accountIdentifier}),{message:n,connectionInfo:o}=yield this.makeRequestV3(c).catch(d=>p(this,void 0,void 0,function*(){throw console.error(d),new Error("TODO")}));return yield t.handleResponse({request:c,account:i,output:n,blockExplorer:this.blockExplorer,connectionContext:o,walletInfo:yield this.getWalletInfo()}),n.message})}requestPermissions(e){return p(this,void 0,void 0,function*(){const t={appMetadata:yield this.getOwnAppMetadata(),type:E.PermissionRequest,network:e&&e.network?e.network:{type:S.MAINNET},scopes:e&&e.scopes?e.scopes:[P.OPERATION_REQUEST,P.SIGN]};this.analytics.track("event","DAppClient","Permission requested");const{message:i,connectionInfo:c}=yield this.makeRequest(t).catch(a=>p(this,void 0,void 0,function*(){throw yield this.handleRequestError(t,a)})),n=i.publicKey||i.pubkey||i.pubKey,o=yield ke(n);console.log("######## MESSAGE #######"),console.log(i);const d=yield this.storage.get(U.LAST_SELECTED_WALLET),h={accountIdentifier:yield ne(o,i.network),senderId:i.senderId,origin:{type:c.origin,id:c.id},walletKey:d,address:o,publicKey:n,network:i.network,scopes:i.scopes,threshold:i.threshold,notification:i.notification,connectedAt:new Date().getTime()};console.log("######## ACCOUNT INFO #######"),console.log(JSON.stringify(h)),yield this.accountManager.addAccount(h),yield this.setActiveAccount(h);const s=Object.assign(Object.assign({},i),{walletKey:d,address:o,accountInfo:h});return yield this.notifySuccess(t,{account:h,output:s,blockExplorer:this.blockExplorer,connectionContext:c,walletInfo:yield this.getWalletInfo()}),this.analytics.track("event","DAppClient","Permission received",{address:o}),s})}requestSignPayload(e){return p(this,void 0,void 0,function*(){if(!e.payload)throw yield this.sendInternalError("Payload must be provided");const t=yield this.getActiveAccount();if(!t)throw yield this.sendInternalError("No active account!");const i=e.payload;if(typeof i!="string")throw new Error("Payload must be a string");const c=(()=>{switch(e.signingType){case k.OPERATION:if(!i.startsWith("03"))throw new Error('When using signing type "OPERATION", the payload must start with prefix "03"');return k.OPERATION;case k.MICHELINE:if(!i.startsWith("05"))throw new Error('When using signing type "MICHELINE", the payload must start with prefix "05"');return k.MICHELINE;case k.RAW:default:return k.RAW}})();this.analytics.track("event","DAppClient","Signature requested");const n={type:E.SignPayloadRequest,signingType:c,payload:i,sourceAddress:e.sourceAddress||t.address},{message:o,connectionInfo:d}=yield this.makeRequest(n).catch(h=>p(this,void 0,void 0,function*(){throw yield this.handleRequestError(n,h)}));return yield this.notifySuccess(n,{account:t,output:o,connectionContext:d,walletInfo:yield this.getWalletInfo()}),this.analytics.track("event","DAppClient","Signature response"),o})}requestOperation(e){return p(this,void 0,void 0,function*(){if(!e.operationDetails)throw yield this.sendInternalError("Operation details must be provided");const t=yield this.getActiveAccount();if(!t)throw yield this.sendInternalError("No active account!");const i={type:E.OperationRequest,network:t.network||{type:S.MAINNET},operationDetails:e.operationDetails,sourceAddress:t.address||""};this.analytics.track("event","DAppClient","Operation requested");const{message:c,connectionInfo:n}=yield this.makeRequest(i).catch(o=>p(this,void 0,void 0,function*(){throw yield this.handleRequestError(i,o)}));return yield this.notifySuccess(i,{account:t,output:c,blockExplorer:this.blockExplorer,connectionContext:n,walletInfo:yield this.getWalletInfo()}),this.analytics.track("event","DAppClient","Operation response"),c})}requestBroadcast(e){return p(this,void 0,void 0,function*(){if(!e.signedTransaction)throw yield this.sendInternalError("Signed transaction must be provided");const t=e.network||{type:S.MAINNET},i={type:E.BroadcastRequest,network:t,signedTransaction:e.signedTransaction};this.analytics.track("event","DAppClient","Broadcast requested");const{message:c,connectionInfo:n}=yield this.makeRequest(i).catch(o=>p(this,void 0,void 0,function*(){throw yield this.handleRequestError(i,o)}));return yield this.notifySuccess(i,{network:t,output:c,blockExplorer:this.blockExplorer,connectionContext:n,walletInfo:yield this.getWalletInfo()}),this.analytics.track("event","DAppClient","Broadcast response"),c})}setActivePeer(e){return p(this,void 0,void 0,function*(){this._activePeer.isSettled()?this._activePeer=b.resolve(e):this._activePeer.resolve(e),e&&(yield this.initInternalTransports(),e.type==="postmessage-pairing-response"?yield this.setTransport(this.postMessageTransport):e.type==="p2p-pairing-response"&&(yield this.setTransport(this.p2pTransport)))})}setTransport(e){const t=Object.create(null,{setTransport:{get:()=>super.setTransport}});return p(this,void 0,void 0,function*(){e||(this._initPromise=void 0);const i=t.setTransport.call(this,e);return yield this.events.emit(l.ACTIVE_TRANSPORT_SET,e),i})}sendInternalError(e){return p(this,void 0,void 0,function*(){throw yield this.events.emit(l.INTERNAL_ERROR,{text:e}),new Error(e)})}removeAccountsForPeers(e){return p(this,void 0,void 0,function*(){const t=yield this.accountManager.getAccounts(),i=e.map(d=>d.senderId),n=t.filter(d=>i.includes(d.senderId)).map(d=>d.accountIdentifier);yield this.accountManager.removeAccounts(n);const o=yield this.getActiveAccount();o&&n.includes(o.accountIdentifier)&&(yield this.setActiveAccount(void 0))})}handleRequestError(e,t){return p(this,void 0,void 0,function*(){if(y.error("handleRequestError","error response",t),t.errorType){const i=[];if(t.errorType===Z.NO_PRIVATE_KEY_FOUND_ERROR){const o=()=>p(this,void 0,void 0,function*(){const d=e;let h;if(d.sourceAddress&&d.network){const s=yield ne(d.sourceAddress,d.network);h=yield this.getAccount(s),h&&(yield this.removeAccount(h.accountIdentifier))}});i.push({text:"Remove account",actionCallback:o})}const c=yield this.getPeer(),n=yield this.getActiveAccount();throw e.type===E.PermissionRequest&&(yield this.getActiveAccount())===void 0&&(this._initPromise=void 0,this.postMessageTransport=void 0,this.p2pTransport=void 0,yield this.setTransport(),yield this.setActivePeer()),this.events.emit(K[e.type].error,{errorResponse:t,walletInfo:yield this.getWalletInfo(c,n),errorMessages:this.errorMessages},i).catch(o=>y.error("handleRequestError",o)),ve.getError(t.errorType,t.errorData)}throw t})}notifySuccess(e,t){return p(this,void 0,void 0,function*(){this.events.emit(K[e.type].success,t).catch(i=>console.warn(i))})}getWalletInfo(e,t){var i,c;return p(this,void 0,void 0,function*(){const n=t||(yield this.getActiveAccount()),o=e||(yield this.getPeer(n));let d;n&&(d=yield this.appMetadataManager.getAppMetadata(n.senderId));const h=o;d||(d={name:h==null?void 0:h.name,icon:h==null?void 0:h.icon});const s=(f,N)=>f&&N?f.toLowerCase()===N.toLowerCase():!1;let a,u;if(oe().find(f=>s(f.name,d==null?void 0:d.name))?(a=oe().find(f=>s(f.name,d==null?void 0:d.name)),u="mobile"):se().find(f=>s(f.name,d==null?void 0:d.name))?(a=se().find(f=>s(f.name,d==null?void 0:d.name)),u="web"):re().find(f=>s(f.name,d==null?void 0:d.name))?(a=re().find(f=>s(f.name,d==null?void 0:d.name)),u="desktop"):ce().find(f=>s(f.name,d==null?void 0:d.name))&&(a=ce().find(f=>s(f.name,d==null?void 0:d.name)),u="extension"),a){let f;return a.hasOwnProperty("links")?f=a.links[(i=n==null?void 0:n.network.type)!==null&&i!==void 0?i:this.preferredNetwork]:a.hasOwnProperty("deepLink")&&(f=a.deepLink),{name:d.name,icon:(c=d.icon)!==null&&c!==void 0?c:a.logo,deeplink:f,type:u}}return d})}getPeer(e){var t,i,c,n,o,d;return p(this,void 0,void 0,function*(){let h;if(e){y.log("getPeer","We have an account",e);const s=(i=yield(t=this.postMessageTransport)===null||t===void 0?void 0:t.getPeers())!==null&&i!==void 0?i:[],a=(n=yield(c=this.p2pTransport)===null||c===void 0?void 0:c.getPeers())!==null&&n!==void 0?n:[],u=(d=yield(o=this.walletConnectTransport)===null||o===void 0?void 0:o.getPeers())!==null&&d!==void 0?d:[],f=[...s,...a,...u];y.log("getPeer","Found peers",f,e),h=f.find(N=>N.senderId===e.senderId),h||(h=f.find(N=>N.extensionId===e.origin.id))}else h=yield this._activePeer.promise,y.log("getPeer","Active peer",h);return h})}makeRequest(e){var t;return p(this,void 0,void 0,function*(){const i=yield ae();if(console.time(i),y.log("makeRequest","starting"),yield this.init(),console.timeLog(i,"init done"),y.log("makeRequest","after init"),yield this.addRequestAndCheckIfRateLimited())throw this.events.emit(l.LOCAL_RATE_LIMIT_REACHED).catch(a=>console.warn(a)),new Error("rate limit reached");if(!(yield this.checkPermissions(e.type)))throw this.events.emit(l.NO_PERMISSIONS).catch(a=>console.warn(a)),new Error("No permissions to send this request to wallet!");if(!this.beaconId)throw yield this.sendInternalError("BeaconID not defined");const c=Object.assign({id:i,version:"2",senderId:yield le(yield this.beaconId)},e),n=new b;this.addOpenRequest(c.id,n);const o=yield new de().serialize(c),d=yield this.getActiveAccount(),h=yield this.getPeer(d),s=yield this.getWalletInfo(h,d);y.log("makeRequest","sending message",c),console.timeLog(i,"sending");try{yield(yield this.transport).send(o,h)}catch(a){throw this.events.emit(l.INTERNAL_ERROR,{text:"Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",buttons:[{text:"Reset Connection",actionCallback:()=>p(this,void 0,void 0,function*(){yield I(),this.disconnect()})}]}),console.timeLog(i,"send error"),a}return console.timeLog(i,"sent"),this.events.emit(K[e.type].sent,{walletInfo:Object.assign(Object.assign({},s),{name:(t=s.name)!==null&&t!==void 0?t:"Wallet"}),extraInfo:{resetCallback:()=>p(this,void 0,void 0,function*(){this.disconnect()})}}).catch(a=>console.warn(a)),n.promise})}makeRequestV3(e){var t;return p(this,void 0,void 0,function*(){const i=yield ae();if(console.time(i),y.log("makeRequest","starting"),yield this.init(),console.timeLog(i,"init done"),y.log("makeRequest","after init"),yield this.addRequestAndCheckIfRateLimited())throw this.events.emit(l.LOCAL_RATE_LIMIT_REACHED).catch(u=>console.warn(u)),new Error("rate limit reached");if(!this.beaconId)throw yield this.sendInternalError("BeaconID not defined");const c={id:i,version:"3",senderId:yield le(yield this.beaconId),message:e},n=new b;this.addOpenRequest(c.id,n);const o=yield new de().serialize(c),d=yield this.getActiveAccount(),h=yield this.getPeer(d),s=yield this.getWalletInfo(h,d);y.log("makeRequest","sending message",c),console.timeLog(i,"sending");try{yield(yield this.transport).send(o,h)}catch(u){throw this.events.emit(l.INTERNAL_ERROR,{text:"Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",buttons:[{text:"Reset Connection",actionCallback:()=>p(this,void 0,void 0,function*(){yield I(),this.disconnect()})}]}),console.timeLog(i,"send error"),u}console.timeLog(i,"sent");const a=e.type;return this.events.emit(K[a].sent,{walletInfo:Object.assign(Object.assign({},s),{name:(t=s.name)!==null&&t!==void 0?t:"Wallet"}),extraInfo:{resetCallback:()=>p(this,void 0,void 0,function*(){this.disconnect()})}}).catch(u=>console.warn(u)),n.promise})}disconnect(){return p(this,void 0,void 0,function*(){this.postMessageTransport=void 0,this.p2pTransport=void 0,this.walletConnectTransport=void 0,yield Promise.all([this.clearActiveAccount(),(yield this.transport).disconnect()])})}addOpenRequest(e,t){y.log("addOpenRequest",this.name,`adding request ${e} and waiting for answer`),this.openRequests.set(e,t)}sendNotificationWithAccessToken(e){return p(this,void 0,void 0,function*(){const{url:t,recipient:i,title:c,body:n,payload:o,protocolIdentifier:d,accessToken:h}=e,s=new Date().toISOString(),a=yield this.keyPair,u=a.publicKey,f=W.Buffer.from(new Uint8Array([13,15,37,217])),N=Be.encode(W.Buffer.concat([f,W.Buffer.from(u)])),A=["Tezos Signed Message: ",i,c,n,s,o].join(" "),R=Ue(A),_="0501"+R.length.toString(16).padStart(8,"0")+R,G=yield Le(_,{secretKey:W.Buffer.from(a.secretKey)});return(yield De.post(`${t}/send`,{recipient:i,title:c,body:n,timestamp:s,payload:o,accessToken:h,protocolIdentifier:d,sender:{name:this.name,publicKey:N,signature:G}})).data})}}let m;const ht=(r,e)=>(m&&e&&(m.disconnect(),m=void 0),m||(m||(m=new dt(r)),m));function g(r,e,t,i){function c(n){return n instanceof t?n:new t(function(o){o(n)})}return new(t||(t=Promise))(function(n,o){function d(a){try{s(i.next(a))}catch(u){o(u)}}function h(a){try{s(i.throw(a))}catch(u){o(u)}}function s(a){a.done?n(a.value):c(a.value).then(d,h)}s((i=i.apply(r,e||[])).next())})}const Et={commitHash:"bcc2118ddfafc1995fd125cd74d198fda042bf48",version:"16.1.2"};class fe extends Error{constructor(){super("You need to initialize BeaconWallet by calling beaconWallet.requestPermissions first"),this.name="BeaconWalletNotInitialized"}}class ut extends Error{constructor(e){super(`Required permissions scopes were not granted: ${e.join(",")}`),this.requiredScopes=e,this.name="MissingRequiredScopes"}}class vt{constructor(e){this.client=ht(e)}validateRequiredScopesOrFail(e,t){const i=new Set(t);for(const c of e)i.has(c)&&i.delete(c);if(i.size>0)throw new ut(Array.from(i))}requestPermissions(e){return g(this,void 0,void 0,function*(){yield this.client.requestPermissions(e)})}getPKH(){return g(this,void 0,void 0,function*(){const e=yield this.client.getActiveAccount();if(!e)throw new fe;return e.address})}mapTransferParamsToWalletParams(e){return g(this,void 0,void 0,function*(){let t;yield this.client.showPrepare();try{t=yield e()}catch(i){throw yield this.client.hideUI(),i}return this.removeDefaultParams(t,yield Me(this.formatParameters(t)))})}mapIncreasePaidStorageWalletParams(e){return g(this,void 0,void 0,function*(){let t;yield this.client.showPrepare();try{t=yield e()}catch(i){throw yield this.client.hideUI(),i}return this.removeDefaultParams(t,yield xe(this.formatParameters(t)))})}mapOriginateParamsToWalletParams(e){return g(this,void 0,void 0,function*(){let t;yield this.client.showPrepare();try{t=yield e()}catch(i){throw yield this.client.hideUI(),i}return this.removeDefaultParams(t,yield We(this.formatParameters(t)))})}mapDelegateParamsToWalletParams(e){return g(this,void 0,void 0,function*(){let t;yield this.client.showPrepare();try{t=yield e()}catch(i){throw yield this.client.hideUI(),i}return this.removeDefaultParams(t,yield qe(this.formatParameters(t)))})}formatParameters(e){return e.fee&&(e.fee=e.fee.toString()),e.storageLimit&&(e.storageLimit=e.storageLimit.toString()),e.gasLimit&&(e.gasLimit=e.gasLimit.toString()),e}removeDefaultParams(e,t){return e.fee||delete t.fee,e.storageLimit||delete t.storage_limit,e.gasLimit||delete t.gas_limit,t}sendOperations(e){return g(this,void 0,void 0,function*(){const t=yield this.client.getActiveAccount();if(!t)throw new fe;const i=t.scopes;this.validateRequiredScopesOrFail(i,[P.OPERATION_REQUEST]);const{transactionHash:c}=yield this.client.requestOperation({operationDetails:e});return c})}disconnect(){return g(this,void 0,void 0,function*(){yield this.client.destroy()})}clearActiveAccount(){return g(this,void 0,void 0,function*(){yield this.client.setActiveAccount()})}}export{vt as BeaconWallet,fe as BeaconWalletNotInitialized,ut as MissingRequiredScopes,Et as VERSION};
